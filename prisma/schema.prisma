// Prisma schema draft for Taskwatch personal project

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Visibility {
  PRIVATE
  PUBLIC
}

enum OccurrenceStatus {
  SCHEDULED
  DONE
  MISSED
}

enum ReactionType {
  LIKE
  BAD
}

enum FriendRequestStatus {
  PENDING
  ACCEPTED
  REJECTED
  CANCELLED
}

enum TimelinePostKind {
  AUTO_DONE
  AUTO_MISSED
  MANUAL_NOTE
}

model User {
  id             String          @id @default(dbgenerated("uuidv7()")) @db.Uuid
  email          String          @unique
  name           String
  avatar         String?
  avatar_color   String?
  xp             Int             @default(0)
  level          Int             @default(1)
  streak_count   Int             @default(0)
  created_at     DateTime        @default(now())
  updated_at     DateTime        @updatedAt

  events                  Event[]
  occurrences             Occurrence[]
  timeline_posts          TimelinePost[]
  reactions               Reaction[]
  friendships_as_a        Friendship[]          @relation("FriendshipUserA")
  friendships_as_b        Friendship[]          @relation("FriendshipUserB")
  sent_friend_requests    FriendRequest[]       @relation("FriendRequestRequester")
  received_friend_requests FriendRequest[]       @relation("FriendRequestReceiver")

  @@index([name])
  @@map("users")
}

model Event {
  id               String          @id @default(dbgenerated("uuidv7()")) @db.Uuid
  user_id          String          @db.Uuid
  title            String
  tag              String?
  description      String?
  visibility       Visibility      @default(PRIVATE)
  duration_minutes Int
  rrule            String?
  exdates          DateTime[]      @default([])
  created_at       DateTime        @default(now())
  updated_at       DateTime        @updatedAt

  user             User            @relation(fields: [user_id], references: [id], onDelete: Cascade)
  occurrences      Occurrence[]

  @@index([user_id, visibility])
  @@map("events")
}

model Occurrence {
  id             String           @id @default(dbgenerated("uuidv7()")) @db.Uuid
  event_id       String           @db.Uuid
  user_id        String           @db.Uuid
  start_at       DateTime
  end_at         DateTime
  status         OccurrenceStatus @default(SCHEDULED)
  completed_at   DateTime?
  notes          String?
  created_at     DateTime         @default(now())
  updated_at     DateTime         @updatedAt

  event          Event            @relation(fields: [event_id], references: [id], onDelete: Cascade)
  user           User             @relation(fields: [user_id], references: [id], onDelete: Cascade)
  timeline_posts TimelinePost[]

  @@index([user_id, status])
  @@index([event_id, start_at])
  @@map("occurrences")
}

model TimelinePost {
  id             String          @id @default(dbgenerated("uuidv7()")) @db.Uuid
  user_id        String          @db.Uuid
  occurrence_id  String?         @db.Uuid
  message        String
  kind           TimelinePostKind @default(AUTO_DONE)
  memo           String?
  memo_updated_at DateTime?
  visibility     Visibility      @default(PRIVATE)
  created_at     DateTime        @default(now())
  updated_at     DateTime        @updatedAt

  user           User            @relation(fields: [user_id], references: [id], onDelete: Cascade)
  occurrence     Occurrence?     @relation(fields: [occurrence_id], references: [id], onDelete: SetNull)
  reactions      Reaction[]

  @@unique([occurrence_id])
  @@index([user_id, visibility])
  @@map("timeline_posts")
}

model Reaction {
  id         String        @id @default(dbgenerated("uuidv7()")) @db.Uuid
  post_id    String        @db.Uuid
  user_id    String        @db.Uuid
  type       ReactionType
  created_at DateTime      @default(now())

  post       TimelinePost  @relation(fields: [post_id], references: [id], onDelete: Cascade)
  user       User          @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([post_id, user_id])
  @@index([user_id])
  @@map("reactions")
}

model Friendship {
  id             String      @id @default(dbgenerated("uuidv7()")) @db.Uuid
  user_a_id      String      @db.Uuid
  user_b_id      String      @db.Uuid
  created_at     DateTime    @default(now())
  updated_at     DateTime    @updatedAt

  user_a         User        @relation("FriendshipUserA", fields: [user_a_id], references: [id], onDelete: Cascade)
  user_b         User        @relation("FriendshipUserB", fields: [user_b_id], references: [id], onDelete: Cascade)

  @@unique([user_a_id, user_b_id])
  @@index([user_b_id])
  @@map("friendships")
}

model FriendRequest {
  id            String               @id @default(dbgenerated("uuidv7()")) @db.Uuid
  requester_id  String               @db.Uuid
  receiver_id   String               @db.Uuid
  status        FriendRequestStatus  @default(PENDING)
  created_at    DateTime             @default(now())
  responded_at  DateTime?

  requester     User @relation("FriendRequestRequester", fields: [requester_id], references: [id], onDelete: Cascade)
  receiver      User @relation("FriendRequestReceiver", fields: [receiver_id], references: [id], onDelete: Cascade)

  @@unique([requester_id, receiver_id])
  @@index([receiver_id, status])
  @@index([requester_id, status])
  @@map("friend_requests")
}
